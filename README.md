# vue-fusion

web端应用与移动端混合应用通用开发框架，主要技术栈为vue、vite和typeScript。

**_本仓库仅作示例使用，目的是展示在人力资源有限、需求难度适中、前后端对接问题频发的情况下个人对前端框架设计的思考。_**

**_部分资源被移除，部分实现被简化，部分依赖未打包而是直接展示代码。_**

## 设计理念

### 优化目标

以提升开发效率、应用可靠性和代码可维护性为核心目标，兼顾性能、安全性、可访问性和用户体验。

### 设计原则

- 力求以最小的成本谋取最大的收益。
- 不过度追求非必要功能。

### 开发效率

- 核心是复用。
- 自建业务组件库、业务模板库和通用样式库。
  - 采用多重封装的方法，在提升易用性的同时保持灵活性。
  - 组件向配置化、命令式的方向发展，减少template、style部分的内容。
- 代码标准化。
  - 方便重用。
  - 方便AI模仿。
  - 降低错误率，降低测试成本。

### 可靠性

- 纯前端逻辑正确。
  - 把握数据流，把握数据流向，把握每个节点的输入输出类型，把握每个节点在成功和失败两种情况下的处理方案。
  - 进行足够的测试。由于编写单元测试的成本太高，所以设计中使用mock形成测试数据，再由人工手动进行测试。
- 提高对异常数据的容错能力。
  - 要求任何数据问题都不能导致前端页面整体或局部崩溃。
  - 统一隔离后端数据。
  - 用户的输入需校验后才能使用。
  - 前端自己产生的数据应被完全掌控。
- 提高样式在不同屏幕、不同内容下的自适应能力。
  - 可靠的页面适配方案。
  - 内容驱动设计，而不是照抄设计稿。

### 可维护性

- 快速定位修改点。
  - 职责明确的分层结构。
  - 扁平化的目录结构。
  - 通过注释分割线自定义文件结构，并通过自定义插件展示文件结构。
  - 保持template部分内容简洁，快速定位逻辑入口。
- 缩小修改的影响范围。
  - 通过封装限制状态的作用范围，防止第三方观测状态变化或修改状态，减少隐式通信。
  - 通过组合纯函数来抽象作用于数据之上的操作流，限制对外部状态的影响。
  - css方面，通过vue scoped机制限制作用范围，通过BEM命名法摆脱嵌套结构，通过ITCSS方案让样式的权重和作用范围成反比，避免全局样式覆盖局部样式。
- 减小功能扩展的难度。
  - 函数内功能分支可考虑使用策略模式进行扩展。
  - 组件内以hook形式注入功能，hook之间使用getter和setter进行通信。
  - 在文件的级别利用`import 'xxx'`与`import 'xxx/index'`等效的特性变文件为目录进行扩展。
- 防劣化机制。
  - linter约束。
  - formatter统一格式化。
  - code review。

### 性能

- 两个目标。
  - 快速加载页面。
  - 快速响应用户输入。
- 三个核心指标。
  - 页面最大内容渲染时间。
  - 页面渲染时元素累计偏移量。
  - 用户输入到下一次页面变化的时间。
- 两个瓶颈。
  - CPU瓶颈。宏任务、微任务、GC长时间占用主线程，降低渲染任务的执行频率，从而降低帧率。
    - 分割长任务。
    - 避免在微任务执行过程中不断产生新的微任务，导致微任务队列一直无法被清空。
  - IO瓶颈。均可抽象为资源加载问题。
    - 减少资源体积。压缩、tree shaking、使用新格式等。
    - 优化加载方案。预加载、按需加载、错峰加载、并发加载等。
    - 提高缓存命中率。
- 使用过渡效果弱化用户对时间的感知。

## 项目结构

```
src/
  business/
    example/
      api.ts -- api层
      index.ts -- business层
      mock.ts -- mock层
      model.ts -- model层
  share/
    routes.ts
    ...
  view/ -- view层
    example/ -- 子页面不嵌套
      Example.vue
      business.ts -- 业务逻辑
      nonBusiness.ts -- 非业务逻辑
      example.png -- 静态资源
      components/
        child/
          Child.vue
          GrandChild.vue -- 子组件不嵌套
          ...
      ...
  App.vue
  main.ts
```

完整项目分层为model、mock、api、business和view。其中model定义业务模型，mock定义mock函数，api定义接口函数，business定义业务函数，view实现页面逻辑。

目录结构按领域进行组织，同一业务模块的代码合并到一处，便于管理，留下简化的空间。

该分层方案下，前端将自建一套业务模型，彻底与后端分离，在无接口的情况下也可依靠mock运行完整逻辑。view层与数据的交互全部通过调用business层的接口实现，business层在不同模式下分别调用api层和mock层的接口实现逻辑。business和mock层基于model层定义的业务模型提供接口。

```mermaid
flowchart TB
    view
    business
    mock
    api
    business <--> view
    mock <-- in mock mode --> business
    api <-- in normal mode --> business
```

以上结构适用于开发复杂应用。实际情况下需根据项目难度、时间等因素合理简化结构。比如统计业务一般较简单，无需定义model。

## 开发流程

1. 定义业务模型。

> 引导开发人员在实现功能之前充分理解当前模块的整体业务逻辑。

2. 定义business层业务函数输入输出类型。

> 实现功能之前先明确有什么，要得到什么。

3. 根据业务函数类型定义实现对应的mock函数，并在business层调用。

> 一方面辅助开发，一方面作为测试用例。

4. 使用business层业务函数实现页面逻辑。

5. 实现api层函数。

> 实际开发时通过自定义工具由swagger文档生成整个api层。便于同步接口变化，并通过typescript类型约束提示破坏性变更。

6. 使用api层函数实现business层函数逻辑。

**_测试应贯穿始终。_**

## 其他

### 注释分割线

<img src="https://github.com/niuiic/assets/blob/main/vue-fusion/divider.png" />

### 页面适配方案

- 类rem方案。根字体大小以vh单位定义，实际值小于12px时固定页面高度，固定根字体大小为12px，横向使用flex、grid或流体布局。该方案适用于大屏应用，即正好占满全屏，整体不可滚动，页面内容饱满。
- 自动替换px。
- 可灵活调整。

### 为什么与后端分离

- 应对无接口文档的情况。
- 应对前端进度超越后端的情况。
- 应对后端接口频繁变动的情况。
- 应对后端接口不契合前端逻辑的情况。
- 将绝大部分数据处理抽离到business层，简化view层逻辑。
- 便于mock在本地模拟数据库，实现完整的交互逻辑。

> 可选，满足开发和测试需求，就不需要实现额外的交互逻辑。

- 切断mock与api的联系，避免因api的变动而改动mock。

### mock的职责

- 无接口时辅助页面开发。
- 样式与逻辑测试。
- 为演示系统提供数据支撑。
